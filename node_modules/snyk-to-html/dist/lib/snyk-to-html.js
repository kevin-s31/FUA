#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnykToHtml = void 0;
const _ = require("@snyk/lodash");
const chalk_1 = require("chalk");
const debugModule = require("debug");
const fs = require("fs");
const Handlebars = require("handlebars");
const marked = require("marked");
const moment = require("moment");
const path = require("path");
const vuln_1 = require("./vuln");
const codeutil_1 = require("./codeutil");
const debug = debugModule('snyk-to-html');
const defaultRemediationText = '## Remediation\nThere is no remediation at the moment';
function readFile(filePath, encoding) {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, encoding, (err, data) => {
            if (err) {
                reject(err);
            }
            resolve(data);
        });
    });
}
function handleInvalidJson(reason) {
    if (reason.isInvalidJson) {
        reason.message = reason.message + 'Error running `snyk-to-html`. Please check you are providing the correct parameters. ' +
            'Is the issue persists contact support@snyk.io';
    }
    console.log(reason.message);
}
function promisedParseJSON(json) {
    return new Promise((resolve, reject) => {
        try {
            resolve(JSON.parse(json));
        }
        catch (error) {
            error.message = chalk_1.default.red.bold('The source provided is not a valid json! Please validate that the input provided to the CLI is an actual JSON\n\n' +
                'Tip: To find more information, try running `snyk-to-html` in debug mode by appending to the CLI the `-d` parameter\n\n');
            debug(`Input provided to the CLI: \n${json}\n\n`);
            error.isInvalidJson = true;
            reject(error);
        }
    });
}
class SnykToHtml {
    static run(dataSource, remediation, hbsTemplate, summary, reportCallback) {
        SnykToHtml
            .runAsync(dataSource, remediation, hbsTemplate, summary)
            .then(reportCallback)
            .catch(handleInvalidJson);
    }
    static async runAsync(source, remediation, template, summary) {
        const promisedString = source ? readFile(source, 'utf8') : readInputFromStdin();
        return promisedString
            .then(promisedParseJSON).then((data) => {
            var _a;
            if ((data === null || data === void 0 ? void 0 : data.infrastructureAsCodeIssues) || ((_a = data[0]) === null || _a === void 0 ? void 0 : _a.infrastructureAsCodeIssues)) {
                // for IaC input we need to change the default template to an IaC specific template
                // at the same time we also want to support the -t / --template flag
                template =
                    template === path.join(__dirname, '../../template/test-report.hbs')
                        ? path.join(__dirname, '../../template/iac/test-report.hbs')
                        : template;
                return processIacData(data, template, summary);
            }
            else if ((data === null || data === void 0 ? void 0 : data.runs) && (data === null || data === void 0 ? void 0 : data.runs[0].tool.driver.name) === 'SnykCode') {
                template =
                    template === path.join(__dirname, '../../template/test-report.hbs')
                        ? path.join(__dirname, '../../template/code/test-report.hbs')
                        : template;
                return processCodeData(data, template, summary);
            }
            else {
                return processData(data, remediation, template, summary);
            }
        });
    }
}
exports.SnykToHtml = SnykToHtml;
function metadataForVuln(vuln) {
    let { cveSpaced, cveLineBreaks } = concatenateCVEs(vuln);
    return {
        id: vuln.id,
        title: vuln.title,
        name: vuln.name,
        info: vuln.info || 'No information available.',
        severity: vuln.severity,
        severityValue: vuln_1.severityMap[vuln.severity],
        description: vuln.description || 'No description available.',
        fixedIn: vuln.fixedIn,
        packageManager: vuln.packageManager,
        version: vuln.version,
        cvssScore: vuln.cvssScore,
        cveSpaced: cveSpaced || 'No CVE found.',
        cveLineBreaks: cveLineBreaks || 'No CVE found.',
        disclosureTime: dateFromDateTimeString(vuln.disclosureTime || ''),
        publicationTime: dateFromDateTimeString(vuln.publicationTime || ''),
        license: vuln.license || undefined
    };
}
function concatenateCVEs(vuln) {
    let cveSpaced = '';
    let cveLineBreaks = '';
    if (vuln.identifiers) {
        vuln.identifiers.CVE.forEach(function (c) {
            let cveLink = `<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=${c}">${c}</a>`;
            cveSpaced += `${cveLink}&nbsp;`;
            cveLineBreaks += `${cveLink}</br>`;
        });
    }
    return { cveSpaced, cveLineBreaks };
}
function dateFromDateTimeString(dateTimeString) {
    return dateTimeString.substr(0, 10);
}
function groupVulns(vulns) {
    const result = {};
    let uniqueCount = 0;
    let pathsCount = 0;
    if (vulns && Array.isArray(vulns)) {
        vulns.map(vuln => {
            if (!result[vuln.id]) {
                result[vuln.id] = { list: [vuln], metadata: metadataForVuln(vuln) };
                pathsCount++;
                uniqueCount++;
            }
            else {
                result[vuln.id].list.push(vuln);
                pathsCount++;
            }
        });
    }
    return {
        vulnerabilities: result,
        vulnerabilitiesUniqueCount: uniqueCount,
        vulnerabilitiesPathsCount: pathsCount,
    };
}
async function compileTemplate(fileName) {
    return readFile(fileName, 'utf8').then(Handlebars.compile);
}
async function registerPeerPartial(templatePath, name) {
    const dir = path.dirname(templatePath);
    const file = path.join(dir, `test-report.${name}.hbs`);
    const template = await compileTemplate(file);
    Handlebars.registerPartial(name, template);
}
async function generateTemplate(data, template, showRemediation, summary) {
    if (showRemediation && data.remediation) {
        data.showRemediations = showRemediation;
        const { upgrade, pin, unresolved, patch } = data.remediation;
        data.anyRemediations = !_.isEmpty(upgrade) ||
            !_.isEmpty(patch) || !_.isEmpty(pin);
        data.anyUnresolved = !!(unresolved === null || unresolved === void 0 ? void 0 : unresolved.vulnerabilities);
        data.unresolved = groupVulns(unresolved);
        data.upgrades = vuln_1.getUpgrades(upgrade, data.vulnerabilities);
        data.pins = vuln_1.getUpgrades(pin, data.vulnerabilities);
        data.patches = vuln_1.addIssueDataToPatch(patch, data.vulnerabilities);
    }
    const vulnMetadata = groupVulns(data.vulnerabilities);
    const sortedVulns = _.orderBy(vulnMetadata.vulnerabilities, ['metadata.severityValue', 'metadata.name'], ['desc', 'desc']);
    data.hasMetatableData = !!data.projectName || !!data.path || !!data.displayTargetFile;
    data.vulnerabilities = sortedVulns;
    data.uniqueCount = vulnMetadata.vulnerabilitiesUniqueCount;
    data.summary = vulnMetadata.vulnerabilitiesPathsCount + ' vulnerable dependency paths';
    data.showSummaryOnly = summary;
    await registerPeerPartial(template, 'inline-css');
    await registerPeerPartial(template, 'header');
    await registerPeerPartial(template, 'metatable-css');
    await registerPeerPartial(template, 'metatable');
    await registerPeerPartial(template, 'inline-js');
    await registerPeerPartial(template, 'vuln-card');
    await registerPeerPartial(template, 'remediation-css');
    await registerPeerPartial(template, 'actionable-remediations');
    const htmlTemplate = await compileTemplate(template);
    return htmlTemplate(data);
}
async function generateIacTemplate(data, template) {
    await registerPeerPartial(template, 'inline-css');
    await registerPeerPartial(template, 'header');
    await registerPeerPartial(template, 'metatable-css');
    await registerPeerPartial(template, 'metatable');
    await registerPeerPartial(template, 'inline-js');
    await registerPeerPartial(template, 'vuln-card');
    const htmlTemplate = await compileTemplate(template);
    return htmlTemplate(data);
}
async function generateCodeTemplate(data, template) {
    await registerPeerPartial(template, 'inline-css');
    await registerPeerPartial(template, 'inline-js');
    await registerPeerPartial(template, 'header');
    await registerPeerPartial(template, 'metatable-css');
    await registerPeerPartial(template, 'metatable');
    await registerPeerPartial(template, 'code-snip');
    const htmlTemplate = await compileTemplate(template);
    return htmlTemplate(data);
}
function mergeData(dataArray) {
    const vulnsArrays = dataArray.map(project => project.vulnerabilities || []);
    const aggregateVulnerabilities = [].concat(...vulnsArrays);
    const totalUniqueCount = dataArray.reduce((acc, item) => acc + item.vulnerabilities.length || 0, 0);
    const totalDepCount = dataArray.reduce((acc, item) => acc + item.dependencyCount || 0, 0);
    const paths = dataArray.map(project => ({ path: project.path, packageManager: project.packageManager }));
    return {
        vulnerabilities: aggregateVulnerabilities,
        uniqueCount: totalUniqueCount,
        summary: aggregateVulnerabilities.length + ' vulnerable dependency paths',
        dependencyCount: totalDepCount,
        paths,
    };
}
async function processData(data, remediation, template, summary) {
    const mergedData = Array.isArray(data) ? mergeData(data) : data;
    return generateTemplate(mergedData, template, remediation, summary);
}
async function processIacData(data, template, summary) {
    if (data.error) {
        return generateIacTemplate(data, template);
    }
    const dataArray = Array.isArray(data) ? data : [data];
    dataArray.forEach(project => {
        project.infrastructureAsCodeIssues.forEach(issue => {
            issue.severityValue = vuln_1.severityMap[issue.severity];
        });
    });
    const projectsArrays = dataArray.map((project) => {
        return {
            targetFile: project.targetFile,
            targetFilePath: project.targetFilePath,
            projectType: vuln_1.IacProjectType[project.projectType],
            infrastructureAsCodeIssues: _.orderBy(project.infrastructureAsCodeIssues, ['severityValue', 'title'], ['desc', 'asc']),
        };
    });
    const totalIssues = projectsArrays.reduce((acc, item) => acc + item.infrastructureAsCodeIssues.length || 0, 0);
    const processedData = {
        projects: projectsArrays,
        showSummaryOnly: summary,
        totalIssues,
    };
    return generateIacTemplate(processedData, template);
}
async function processCodeData(data, template, summary) {
    if (data.error) {
        return generateCodeTemplate(data, template);
    }
    const dataArray = Array.isArray(data) ? data : [data];
    const OrderedIssuesArray = await codeutil_1.processSourceCode(dataArray);
    const totalIssues = dataArray[0].runs[0].results.length;
    const processedData = {
        projects: OrderedIssuesArray,
        showSummaryOnly: summary,
        totalIssues,
    };
    return generateCodeTemplate(processedData, template);
}
async function readInputFromStdin() {
    return new Promise((resolve, reject) => {
        let jsonString = '';
        process.stdin.setEncoding('utf8');
        process.stdin.on('readable', () => {
            const chunk = process.stdin.read();
            if (chunk !== null) {
                jsonString += chunk;
            }
        });
        process.stdin.on('error', reject);
        process.stdin.on('end', () => resolve(jsonString));
    });
}
// handlebar helpers
const hh = {
    markdown: marked.parse,
    moment: (date, format) => moment.utc(date).format(format),
    count: data => data && data.length,
    dump: (data, spacer) => JSON.stringify(data, null, spacer || null),
    // block helpers
    /* tslint:disable:only-arrow-functions */
    /* tslint:disable:object-literal-shorthand */
    isDoubleArray: function (data, options) {
        return Array.isArray(data[0]) ? options.fn(data) : options.inverse(data);
    },
    if_eq: function (a, b, opts) {
        return (a === b) ? opts.fn(this) : opts.inverse(this);
    },
    if_any: function (opts, ...args) {
        return args.some(v => !!v) ? opts.fn(this) : opts.inverse(this);
    },
    ifCond: function (v1, operator, v2, options) {
        const choose = (pred) => pred ? options.fn(this) : options.inverse(this);
        switch (operator) {
            // tslint:disable-next-line:triple-equals
            case '==': return choose(v1 == v2);
            case '===': return choose(v1 === v2);
            case '<': return choose(v1 < v2);
            case '<=': return choose(v1 <= v2);
            case '>': return choose(v1 > v2);
            case '>=': return choose(v1 >= v2);
            case '&&': return choose(v1 && v2);
            case '||': return choose(v1 || v2);
            default: return choose(false);
        }
    },
    getRemediation: (description, fixedIn) => {
        // check remediation in the description
        const index = description.indexOf('## Remediation');
        if (index > -1) {
            return marked.parse(description.substring(index));
        }
        // if no remediation in description, try to check in `fixedIn` attribute
        if (Array.isArray(fixedIn) && fixedIn.length) {
            const fixedInJoined = fixedIn.join(', ');
            return marked.parse(`## Remediation\n Fixed in: ${fixedInJoined}`);
        }
        // otherwise, fallback to default message, i.e. No remediation at the moment
        return marked.parse(defaultRemediationText);
    },
    severityLabel: (severity) => {
        return severity[0].toUpperCase();
    },
    startsWith: function (str, start, options) {
        return str.startsWith(start) ? options.fn(this) : options.inverse(this);
    },
};
Object.keys(hh).forEach(k => Handlebars.registerHelper(k, hh[k]));
//# sourceMappingURL=snyk-to-html.js.map